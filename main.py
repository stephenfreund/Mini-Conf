# pylint: disable=global-statement,redefined-outer-name
import argparse
import csv
import glob
import json
import os
import re
from collections import OrderedDict, defaultdict
from datetime import datetime, timedelta
from itertools import chain, groupby
from typing import Any, DefaultDict, Dict, List

import pandas
import pytz
import yaml
from dateutil.parser import parse
from flask import Flask, jsonify, redirect, render_template, send_from_directory
from flask_frozen import Freezer
from flaskext.markdown import Markdown

### https://pldi21-test.slack.com/app_redirect?channel=pldi-a


site_data = {}
by_uid = {}


def main(site_data_path):
    global site_data, extra_files
    extra_files = []
    # Load all for your sitedata one time.
    for f in glob.glob(site_data_path + "/*"):
        extra_files.append(f)
        name, typ = f.split("/")[-1].split(".")
        if typ == "json":
            site_data[name] = json.load(open(f))
        elif typ in {"csv", "tsv"}:
            site_data[name] = list(
                csv.DictReader(filter(lambda row: row[0] != "#", open(f)))
            )
        elif typ == "yml":
            site_data[name] = yaml.load(open(f).read(), Loader=yaml.SafeLoader)
        elif typ == "md":
            site_data[name] = open(f).read()

    for typ in [
        "papers",
        "speakers",
        "workshops",
        "socials",
        "sponsors",
        "tracks",
        "track_pldi",
    ]:
        by_uid[typ] = {}
        for p in site_data[typ]:
            by_uid[typ][p["UID"]] = p

    build_prerecorded()  # fix up name problems here...

    build_speakers()
    build_sponsors()  # after setting up links
    build_socials()  # after setting up links
    build_papers()  # after setting up links
    build_calendars_for_tracks()
    build_pldi_tracks()
    build_workshop_start_end()
    add_aux_events_to_pldi_calendar()

    build_full_calendar()

    build_slack_channels()

    link_talks_to_events()

    print("Data Successfully Loaded")
    return extra_files


# ------------- PLDI CODE -------------------->

#
# We look up Zoom links by id.  See zoom.yml data file
#


def zoomIDForTrack(uid):
    # return by_uid["tracks"][trackUID]["zoom_link"]
    return "zoom." + uid.lower()


def zoomLink(zoomID):
    if site_data["config"].get("redirect_zoom", False):
        return f"zoom.html?key={zoomID}"
    else:
        return site_data["zoom"][zoomID]


# This section takes data files and populates them with additional
# entries.


def channel_for_paper(paper):
    channel = [
        chan["Channel Name"]
        for chan in site_data["slack_channels"]
        if chan["UID"] == paper["UID"]
    ]
    if len(channel) != 1:
        raise AssertionError(f'Slack channel for paper {paper["title"]} not defiled')
    return channel[0]


def channel_from_UID(e):
    return e["UID"].lower()


# Every paper, workshop, track, and sponsor has a
# channel that must be generated by this method.
#
# for each of those entities, you set both the human-readable
# name of the channel and the actual channel.  This distinction
# is only for the demos where we have not made all the channels.
#
# Once Slack is set up fully, the name/channel should be the same
# for all of these.
#
def build_slack_channels():

    for p in site_data["papers"]:
        p["slack_channel"] = channel_for_paper(p)

    for t in ["track", "workshop"]:
        for p in site_data[t + "s"]:
            p["slack_channel"] = channel_from_UID(p)

    for t in ["sponsor"]:
        for p in site_data[t + "s"]:
            p["slack_channel"] = t + "-" + channel_from_UID(p)


def startDate(t):
    return datetime.fromisoformat(t["start"])


#
# calendar_complete is *all* events at colocated and at PLDI.
# This is for the full details in schedule.html
#
def build_full_calendar() -> None:

    # All PLDI events, with abbrev PLDI (instead of PLDI-A or -B), plus
    # all papers.
    calendar_complete = [
        makeEvent("PLDI", x) | {"UID": x["UID"]} for x in site_data["track_pldi"]
    ] + [x.copy() for x in site_data["calendar_all_papers"]]

    # Add all events for all colocated, and make sure these all point to the track pages.
    for track in by_uid["tracks"]:
        if track not in ["pldi-A", "pldi-B"]:
            calendar_complete = calendar_complete + [
                x.copy()
                | {"info_link": "/track_" + track + ".html", "category": "colocated"}
                for x in site_data["calendar_" + track]
                if x["category"] not in ["break", "colocated-session"]
            ]

    # Add all one-offs that didn't fit the above:

    site_data["calendar_complete"] = calendar_complete


# these are the only tracks that have some shared entries so
# we can show the tables of all papers in both tracks.
def build_pldi_tracks():
    for track in ["pldi-A", "pldi-B"]:
        site_data["calendar_" + track] = [
            makeEvent("PLDI", x)
            for x in site_data["track_pldi"]
            if (x.get("trackUID", "") in ["pldi-A", "pldi-B"] or "gather" in x)
            and x["UID"] != "pldi_ind_rec"
        ]


# start with what's in the CSV files to mark events
# for tracks and build full event rep.
def makeEvent(conf_abbrev, ev):
    event = {
        "title": ev["title"],
        "start": ev["start"],
        "end": ev["end"],
        "category": ev["category"],
        "info_link": ev.get("info_link", ""),  # /track_" + trackUID + ".html",
        "tooltip": ev.get("tooltip", ""),
        "conf_abbrev": conf_abbrev,
    }

    if "authors" in ev:
        event = event | {"subtitle": ", ".join(extract_list_field(ev, "authors"))}

    if ev.get("trackUID", "") != "":
        event = event | {
            "track": {
                "location": by_uid["tracks"][ev["trackUID"]]["conf_abbrev"],
                "link": "track_" + ev["trackUID"] + ".html",
            },
            "trackUID": ev["trackUID"],  # stash for filtering later...
        }
    if ev.get("zoom", "") != "":
        event = event | {
            "zoom": {
                "location": ev["zoom"],
                "link": zoomLink(zoomIDForTrack(ev["trackUID"])),
            }
        }
    if ev.get("gather", "") != "":
        event = event | {
            "gather": {
                "location": ev["gather"],
                "link": gatherLink(ev["gather"]),
            }
        }
    return event


def gatherLink(gatherLocation):
    base = site_data["config"]["gather_link"]
    if gatherLocation in site_data["config"]["gather"]:
        return base + "?" + site_data["config"]["gather"].get(gatherLocation)
    else:
        return base


def fix(abbrev):
    if abbrev.startswith("PLDI"):
        return "PLDI"
    return abbrev


def build_one_track(track, abbrev):
    if track not in ["pldi-A", "pldi-B"]:
        site_data["calendar_" + track] = (
            [makeEvent(abbrev, x) for x in site_data["track_" + track]]
            + [
                makeEvent(
                    abbrev,
                    x
                    | {
                        "authors": "<small><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class='font-weight-normal'>Session Chair(s): "
                        + x["session_chairs"]
                        + "<small></span>"
                    },
                )
                for x in site_data["track_colocated"]
                if x["trackUID"] == track and x["session_chairs"] != ""
            ]
            + [
                makeEvent(abbrev, x)
                for x in site_data["track_colocated"]
                if x["trackUID"] == track and x["session_chairs"] == ""
            ]
        )


def build_calendars_for_tracks():
    for track in by_uid["tracks"]:
        build_one_track(track, by_uid["tracks"][track]["conf_abbrev"])

    build_one_track("imop_special", "IMOP")

    site_data["calendar_pldi"] = [
        makeEvent("PLDI", x)
        | {"UID": x["UID"], "info_link": "/track_" + x["trackUID"] + ".html"}
        for x in site_data["track_pldi"]
        if x["UID"] != "pldi_ind_rec"
    ] + [
        makeEvent("Sponsor", x)
        | {"UID": x["UID"], "info_link": "/track_" + x["trackUID"] + ".html"}
        for x in site_data["track_pldi"]
        if x["UID"] == "pldi_ind_rec"
    ]

    site_data["calendar_colocated"] = [
        makeEvent(fix(by_uid["tracks"][x["trackUID"]]["conf_abbrev"]), x)
        | {"UID": x["UID"]}
        for x in site_data.get("track_colocated", {})
    ]


def link_talks_to_events():
    indirect = {}
    for e in site_data["talk-indirect"]:
        indirect[e["talk"]] = e["event"].lower()
    for talk in site_data["prerecorded"]:
        if talk["event"] not in ["pldi", "persist"]:
            if f'calendar_{talk["event"]}' in site_data:
                cal = site_data[f'calendar_{talk["event"]}']
                events = [
                    x
                    for x in cal
                    if indirect.get(talk["title"], talk["title"].lower())
                    == x["title"].lower()
                ]
                assert events != [], talk
                # if events == []:
                #     print(talk["event"] + "," + talk["title"])
                for e in events:
                    e["talk"] = {
                        "location": "Video",
                        "link": f"prerecorded_{talk['UID']}.html",
                    }


#
# Creates site_data["calendar_speaker"] for each speaker.
#
# Each speaker has a list of sessions that *must*
# be in calendar_pldi.csv.
#
# The calendar for a speaker contains events built
# directly from those sessions.
def build_speakers() -> None:
    # Format the session start and end times
    for speaker in by_uid["speakers"].values():
        sessionUIDs = extract_list_field(speaker, "sessions")
        sessionsAsEvents = [
            makeEvent("PLDI", by_uid["track_pldi"][key].copy()) | {"info_link": ""}
            for key in sessionUIDs
            if key in by_uid["track_pldi"]
        ]
        site_data["calendar_" + speaker["UID"]] = sessionsAsEvents

    for x in site_data["calendar_plenary_amas"]:
        x["title"] = (
            x["title"]
            .replace("AMA: ", "")
            .replace("-- live Q&A", "")
            .replace(",", "<br>")
        )

    site_data["calendar_plenary_amas"] = [
        x
        | {
            "title": x["title"] + " -- live Q&A",
            "track": {
                "location": "PLDI-A",
                "link": "track_pldi-A.html",
            },
            "talk": {"location": "Video", "link": f"prerecorded_{x['uid']}.html"},
        }
        for x in site_data["calendar_amas"]
    ]


#
# Creates site_data["calendar_sponsor"] for each sponsor.
#
# Each sponsor has a list of calendar items:
#    - start: 2021-06-20T10:00:00-07:00
#    -  duration: 0.5
#    -  label: "Q&A with Company: See what we do."
#    -  gather: Sponsor Booth
#
# If gather is present, this is in gather at the location
# If gather is not present, this is a zoom call with zoom
# link given in sponsor record.
#
def build_sponsors() -> None:
    # Format the session start and end times
    for sponsor in by_uid["sponsors"].values():
        sponsor = sponsor | site_data.get(
            "sponsor_" + sponsor["UID"], site_data["sponsor_default"]
        )
        cal = []
        for ev in sponsor.get("schedule", []):
            start = ev["start"]
            title = ev["label"]

            if ev.get("end") is None:
                end = start + timedelta(hours=ev["duration"])
            else:
                end = ev["end"]

            event = {
                "title": sponsor["name"] + ": " + title,
                "start": start.isoformat(),
                "end": end.isoformat(),
                "category": "sponsor",
                "info_link": "/sponsor_" + sponsor["UID"] + ".html",
                "conf_abbrev": "Sponsor",
            }

            if ev.get("trackUID", "") != "":
                event = event | {
                    "track": {
                        "location": by_uid["tracks"][ev["trackUID"]]["conf_abbrev"],
                        "link": "track_" + ev["trackUID"] + ".html",
                    },
                    "trackUID": ev["trackUID"],  # stash for filtering later...
                }
            elif ev.get("gather") is None:
                event = event | {
                    "zoom": {"location": "Zoom", "link": zoomLink(sponsor["zoom_link"])}
                }
            else:
                event = event | {
                    "gather": {
                        "location": ev["gather"],
                        "link": gatherLink(ev["gather"]),
                    }
                }
            cal.append(event)

        site_data["calendar_" + sponsor["UID"]] = cal


# Add all sponsor events to main calendar.
# Add all social events to main calendar.
def add_aux_events_to_pldi_calendar():
    for sponsor in by_uid["sponsors"].values():
        site_data["calendar_pldi"].extend(
            [x.copy() for x in site_data["calendar_" + sponsor["UID"]]]
        )

    for social in by_uid["socials"].values():
        site_data["calendar_pldi"].extend(
            [
                x.copy()
                for x in site_data["calendar_socials"][social["UID"]]
                if x.get("global", True)
            ]
        )


# Same as sponsors, but we generate a map calendar_socials from
# UID -> calendar rather than a separate calendar for each UID because
# socials don't get their own pages, and we need a way to iterate
# over all social calendars to build the one main socials page.
def build_socials() -> None:
    site_data["calendar_socials"] = OrderedDict()
    for social in by_uid["socials"].values():
        cal = []
        for ev in social.get("schedule", []):
            start = ev["start"]
            title = social["title"]

            if ev.get("end") is None:
                end = start + timedelta(hours=ev["duration"])
            else:
                end = ev["end"]

            event = {
                "title": title,
                "start": start.isoformat(),
                "end": end.isoformat(),
                "category": "social",
                "info_link": "/socials.html#" + social["UID"],
                "conf_abbrev": "Community",
                "global": ev.get("global", True),
            }
            if ev.get("trackUID", "") != "":
                event = event | {
                    "track": {
                        "location": by_uid["tracks"][ev["trackUID"]]["conf_abbrev"],
                        "link": "track_" + ev["trackUID"] + ".html",
                    },
                    "trackUID": ev["trackUID"],  # stash for filtering later...
                }

            elif ev.get("gather") is None:
                event = event | {
                    "zoom": {"location": "Zoom", "link": zoomLink(social["zoom_link"])}
                }
            else:
                event = event | {
                    "gather": {
                        "location": ev["gather"],
                        "link": gatherLink(ev["gather"]),
                    }
                }

            cal.append(event)

        site_data["calendar_socials"][social["UID"]] = cal


def startEndKey(e):
    return (datetime.fromisoformat(e["start"]), datetime.fromisoformat(e["end"]))


# sort by track location first.  If that fails just use category...
def locationKey(e):
    if "track" in e:
        return e["track"]["location"]
    else:
        return e["category"]


#
# Take all the events in papers and merge ones with
# the same start/end into a single event with subevents
#
def groupPapersBySlot(papers):
    papersSorted = sorted(papers, key=startEndKey)
    groupedPapers = []
    for k, g in groupby(papersSorted, startEndKey):
        gs = list(g)
        if len(gs) > 1:
            # more than one with same start and end time.
            # Technically works for > 2, but the title won't be complete,
            #  and probably a bad idea anyway...
            first = gs[0]
            encompassingEvent = {
                "title": f'{gs[0]["title"]} and {gs[1]["title"]}',
                "start": first["start"],
                "end": first["end"],
                "category": first["category"],
                "subEvents": sorted(gs, key=locationKey),
            }
            groupedPapers.append(encompassingEvent)
        else:
            # only one in group
            groupedPapers.append(gs[0])
    return groupedPapers


#
# Fill in or update the following entries for each paper:
#   sessions, talk_events, poster_events, keywords
# Generates list of all events and list of talk events for each
#
def build_papers() -> None:
    allPaperEvents = []
    calendarForAllPapers = site_data["calendar_papers"]

    for paper in by_uid["papers"].values():
        events = [x for x in calendarForAllPapers if x["paperUID"] == paper["UID"]]

        sessions = []  # includes both talks and posters...
        posterEvents = []
        talkEvents = []

        # These are for the papers.html system:
        paper["sessions"] = []  # all session paper is in.  Eg: 1A and 1
        paper["talk_sessions"] = []  # only talk sessions.  Eg 1A
        paper["talk_times"] = []
        paper["poster_sessions"] = []  # only poster sessions.  Eg: 1
        paper["poster_times"] = []

        # home page for specific paper
        info_link = f'poster_{paper["UID"]}.html'

        for ev in events:
            # get the session the vent belongs to
            sessionUID = ev["session"]
            session = by_uid["track_pldi"][sessionUID]

            # if the paper's even doesn't have it's own time, then the
            # start/end comes from the session.
            start = session["start"] if ev["start"] == "" else ev["start"]
            end = session["end"] if ev["end"] == "" else ev["end"]

            # complete a talk event
            if "pldi_talks" in sessionUID:

                # add session number (1A) to talk sessions and all sessions.
                if "mirror" not in sessionUID:
                    sessionNumber = sessionUID[-2:]
                    talkSession = "Technical Talks " + sessionNumber
                    posterSession = "Posters " + sessionNumber[0]
                    if talkSession not in paper["talk_sessions"]:
                        paper["talk_sessions"].append(talkSession)
                        paper["sessions"].append(talkSession)

                    # add poster session number too (1)
                    if posterSession not in paper["sessions"]:
                        paper["poster_sessions"].append(posterSession)
                        paper["sessions"].append(posterSession)

                # add both talk and poster sessions to keywords.
                keywords = extract_list_field(paper, "keywords")
                if talkSession not in keywords:
                    keywords.append(talkSession)
                if posterSession not in keywords:
                    keywords.append(posterSession)
                paper["keywords"] = "|".join(keywords)

                track = session["trackUID"]
                talkEvent = {
                    "title": "Talk",  # paper["title"],
                    "start": start,
                    "end": end,
                    "category": "paper",
                    "info_link": info_link,
                    "track": {
                        "location": by_uid["tracks"][track]["conf_abbrev"],
                        "link": "track_" + track + ".html",
                    },
                    "conf_abbrev": "PLDI",
                    "trackUID": track,
                }

                # these should always write the same value -- all talks must be in same track!
                paper["talk_location"] = talkEvent["track"]["location"]
                paper["talk_link"] = talkEvent["track"]["link"]

                paper["talk_times"].append(talkEvent["start"])

                talkEvents.append(talkEvent)

                eventForCompleteCalendar = talkEvent | {
                    "title": paper["title"],
                    "subtitle": ", ".join(extract_list_field(paper, "authors")),
                }
                allPaperEvents.append(eventForCompleteCalendar)

            if "pldi_posters" in sessionUID:
                location = "Gather Poster %2.2d" % int(ev["posterNumber"])
                link = site_data["config"]["gather_link"] + site_data[
                    "poster-gather-queries"
                ].get(location, "")
                posterEvent = {
                    "title": "Poster Session",  # paper["title"],
                    "start": start,
                    "end": end,
                    "category": "poster",
                    "info_link": info_link,
                    "gather": {"location": location, "link": link},
                    "conf_abbrev": "PLDI",
                    "trackUID": track,
                }

                paper["poster_times"].append(posterEvent["start"])
                paper["poster_link"] = posterEvent["gather"]["link"]
                paper["poster_location"] = location

                posterEvents.append(posterEvent)

        # all talk/poster events for paper.
        paperEvents = talkEvents.copy()
        paperEvents.extend(posterEvents.copy())
        site_data["calendar_" + paper["UID"]] = paperEvents

    # just talk events for global calendar
    site_data["calendar_all_papers"] = allPaperEvents


#
# Compute the start/end to display on the workshops page
# based on the session data we pulled from Researchr.
# That overrides the manually added data in workshops.yml
#
def build_workshop_start_end():
    for workshop in by_uid["workshops"].values():
        uid = workshop["UID"]
        calendar = site_data["track_colocated"]
        # print(uid)
        # print(calendar)
        start = min([x["start"] for x in calendar if x["trackUID"] == uid])
        end = max([x["end"] for x in calendar if x["trackUID"] == uid])
        workshop["day"] = f"{start} - {end}"


def presentation_id(uid):
    talk = by_uid["prerecorded_slideslive"][uid]
    if (
        talk["Status"] != "incoming"
        and talk["Status"] != "loading"
        and talk["Status"] != "not_recording"
    ):
        # if talk["Status"] == "finished":
        # note that wacky spelling -- this is from SlidsLive...
        return str(talk.get("Presentation lD", ""))
    else:
        return ""


# unfortunate column name mismatch: the SlidesLive file has event
# we need track...
def build_prerecorded():

    # set up indexing...
    slidesLive = {}
    for p in site_data["prerecorded_slideslive"]:
        slidesLive[p["ID"]] = p
    by_uid["prerecorded_slideslive"] = slidesLive

    # map only contains talks that are finished.
    by_uid["prerecorded"] = {}
    for p in site_data["prerecorded"]:
        p["track"] = p["event"]
        pid = presentation_id(p["UID"])
        if pid != "":
            p["presentation_id"] = pid
            by_uid["prerecorded"][p["UID"]] = p

    # take out any that weren't actually recorded
    site_data["prerecorded"] = [
        x for x in site_data["prerecorded"] if x["UID"] in by_uid["prerecorded"]
    ]


# ------------- SERVER CODE -------------------->

app = Flask(__name__)
app.config.from_object(__name__)
freezer = Freezer(app)
markdown = Markdown(app)


# MAIN PAGES


def _data():
    data = {}
    data["config"] = site_data["config"]
    return data


@app.route("/")
def index():
    return redirect("/index.html")


@app.route("/favicon.ico")
def favicon():
    return send_from_directory(site_data_path, "favicon.ico")


# TOP LEVEL PAGES


@app.route("/home.html")
def home():
    tracks = by_uid["tracks"]
    data = _data()
    data["readme"] = site_data["README"]

    data["calendar"] = [
        x.copy() for x in site_data["calendar_pldi"] + site_data["calendar_colocated"]
    ]

    for x in data["calendar"]:
        if x["info_link"] == "/track_.html":
            x["info_link"] = "/track_pldi-A.html"

    # print(data["calendar"])

    for x in data["calendar"]:
        # print(x)
        title = x["title"]
        trackTitle = x["conf_abbrev"]
        if trackTitle == "Infer":
            trackTitle = "Infer Practitioners"

        if title == trackTitle:
            title = "Technical Session"
        elif title.startswith(trackTitle + ":"):
            title = title[len(trackTitle) + 1 :].strip()
        x["title"] = title

    data["colocated"] = [
        (tracks[x]["title"], f"/track_{tracks[x]['UID']}.html")
        for x in [
            "hopl",
            "ismm",
            "lctes",
            "array",
            "infer",
            "maps",
            "planqc",
            "plmw",
            "soap",
        ]
    ] + [("Tutorials", "/workshops.html#tutorials")]
    return render_template("home.html", **data)


@app.route("/caltest.html")
def caltest():
    data = _data()
    return render_template("caltest.html", **data)


@app.route("/index.html")
def login():
    data = _data()
    return render_template("index.html", **data)


@app.route("/zoom.html")
def zoom():
    data = _data()
    return render_template("zoom.html", **data)


@app.route("/help.html")
def about():
    data = _data()
    data["FAQ"] = site_data["faq"]["FAQ"]
    data["getting"] = site_data["faq"]["Getting"]
    data["conduct"] = site_data["faq"]["Code Of Conduct"]
    return render_template("help.html", **data)


@app.route("/paper_vis.html")
def paper_vis():
    data = _data()
    return render_template("papers_vis.html", **data)


@app.route("/papers.html")
def papers():
    data = _data()
    data["papers"] = site_data["papers"]
    return render_template("papers.html", **data)


@app.route("/papers_schedule.html")
def paper_schedule():
    data = _data()
    data["papers"] = site_data["papers"]

    # handy list of *just* the talk sessions, with explicit heading category for viewing
    # Do this here, to ensure track_pldi and calendar_all_papers are set up.
    talk_sessions = [
        makeEvent("PLDI", x) | {"UID": x["UID"]}
        for x in site_data["track_pldi"]
        if "pldi_talks" in x["UID"]
    ]

    data["calendar"] = groupPapersBySlot(
        site_data["calendar_all_papers"] + talk_sessions
    )

    return render_template("papers_schedule.html", **data)


sidewaysTitles = {
    ("SRC Poster Session", "2021-06-22T10:00:00-04:00"): "SRC Posters",
    (
        "SRC Finalist Technical Talks  -- live Q&A",
        "2021-06-24T16:15:00+00:00",
    ): "SRC Talks",
    ("Google: Join us for a Q&A session", "2021-06-24T11:30:00-04:00"): "Google",
    ("Oracle: Chat with Guy Steele", "2021-06-24T12:00:00-04:00"): "Oracle",
    # ('Oracle: Chat with Guy Steele', '2021-06-25T12:00:00-04:00'): "Oracle: Guy Steele",
    (
        "CARES: Building Inclusive Research Environments",
        "2021-06-24T12:00:00-04:00",
    ): "CARES",
    ("PLTea", "2021-06-24T11:30:00-04:00"): "PLTea",
    "SOAP": "SOAP",
    "Infer": "Infer",
    "PLanQC": "PLanQC",
    "PLMW": "PLMW",
    "ISMM": "ISMM",
    "LCTES": "LCTES",
    "ARRAY": "ARRAY",
    "IMOP": "IMOP",
    "Persist": "Persist",
    "Contracts": "Contracts",
    ("MAPS", "2021-06-21 10:45:00-04:00"): "MAPS",
    ("MAPS", "2021-06-21 13:30:00-04:00"): "MAPS",
    ("MAPS", "2021-06-21 15:15:00-04:00"): "MAPS",
    ("HOPL IV", "2021-06-21 09:00:00-04:00"): "HOPL IV",
    ("HOPL IV", "2021-06-21 18:15:00-04:00"): "HOPL IV",
    ("HOPL IV", "2021-06-21 13:30:00-04:00"): "HOPL IV",
    ("HOPL IV", "2021-06-22 09:00:00-04:00"): "HOPL IV",
    ("HOPL IV", "2021-06-22 18:15:00-04:00"): "HOPL IV",
    ("HOPL IV", "2021-06-22 13:30:00-04:00"): "HOPL IV",
}


@app.route("/calendar.html")
def schedule():
    data = _data()
    data["calendar"] = [x.copy() for x in site_data["calendar_pldi"]] + [
        x | {"title": by_uid["tracks"][x["trackUID"]]["conf_abbrev"]}
        for x in site_data["calendar_colocated"]
    ]
    for c in data["calendar"]:
        if c["info_link"] == "/track_.html":
            c["info_link"] = "/track_pldi-A.html"

    for c in data["calendar"]:
        c["sideways"] = sidewaysTitles.get(
            (c["title"], c["start"]), sidewaysTitles.get(c["title"], None)
        )

    rgx = re.compile(" \([^\)]*\)")
    for c in data["calendar"]:
        c["title"] = re.sub(rgx, "", c["title"])

    data["calendar_complete"] = site_data["calendar_complete"]
    return render_template("schedule.html", **data)


@app.route("/plenary.html")
def plenary():
    data = _data()
    data["speakers"] = [format_speaker(speaker) for speaker in site_data["speakers"]]

    talks = [x for x in site_data["prerecorded"] if x["track"] == "amas"]
    data["prerecorded_amas"] = talks

    return render_template("plenary.html", **data)


@app.route("/workshops.html")
def workshops():
    data = _data()
    data["workshops"] = site_data["workshops"]
    return render_template("workshops.html", **data)


@app.route("/socials.html")
def socials():
    data = _data()
    data["socials"] = site_data["socials"]
    data["calendar"] = site_data["calendar_socials"]
    return render_template("socials.html", **data)


@app.route("/sponsors.html")
def sponsors():
    data = _data()
    data["sponsors"] = site_data["sponsors"]
    data["reception"] = [
        x for x in site_data["calendar_pldi"] if x.get("UID", "") == "pldi_ind_rec"
    ][0]
    return render_template("sponsors.html", **data)


def extract_list_field(v, key):
    value = v.get(key, "")
    if isinstance(value, list):
        return value
    else:
        return value.split("|")


def make_channel_name(title):
    return "paper-" + "".join(
        [x.lower() for x in title.replace(" ", "-") if x.isalnum() or x == "-"]
    )


def format_paper(v):
    list_keys = ["authors", "keywords", "sessions", "talk_times", "poster_times"]
    list_fields = {}
    for key in list_keys:
        list_fields[key] = extract_list_field(v, key)
    # not all of these are used right now.
    return {
        "UID": v["UID"],
        "title": v["title"],
        "forum": v["UID"],
        "authors": list_fields["authors"],
        "keywords": list_fields["keywords"],
        # "abstract": v["abstract"],
        "abstract": site_data["pldi-abstracts"][v["UID"]],
        "TLDR": v["abstract"],
        "recs": [],
        "sessions": v["sessions"],
        "talk_sessions": v["talk_sessions"],
        "talk_location": v.get("talk_location", ""),
        "talk_link": v.get("talk_link", ""),
        "talk_times": v["talk_times"],
        "poster_sessions": v["poster_sessions"],
        "poster_location": v.get("poster_location", ""),
        "poster_link": v.get("poster_link", ""),
        "poster_times": v["poster_times"],
        # links to external content per poster -- fix up later!
        "pdf_url": v.get("pdf_url", ""),  # render poster from this PDF
        "code_link": "https://github.com/Mini-Conf/Mini-Conf",  # link to code
        "paper_link": paperLink(v),
        "calendar": site_data["calendar_" + v["UID"]],
        "chat": make_channel_name(v["title"]),  # remove if not rocket chat.
        "slack_channel": v["slack_channel"],
        "short_presentation_id": presentation_id(v["UID"] + ".short"),
        "long_presentation_id": presentation_id(v["UID"] + ".long"),
    }


def paperLink(paper):
    if not site_data["config"]["use_acm_dl"]:
        id = paper["UID"].split(".")[1]
        return f"https://gh-posters.dgzedp99wf8of.amplifyapp.com/pldi21main-p{id}-p.pdf"
    else:
        return "https://doi.org/" + paper["DOI"]


def format_workshop(v):
    list_keys = ["authors"]
    list_fields = {}
    for key in list_keys:
        list_fields[key] = extract_list_field(v, key)

    return {
        "id": v["UID"],
        "title": v["title"],
        "organizers": list_fields["authors"],
        "abstract": v["abstract"],
    }


def format_track_streams(v):
    list_keys = ["stream_times", "presentation_ids"]
    list_fields = {}
    for key in list_keys:
        list_fields[key] = extract_list_field(v, key)

    presentationIds = list_fields["presentation_ids"]
    streamTimes = list_fields["stream_times"]

    streamData = []
    for times, id in zip(streamTimes, presentationIds):
        parts = times.split(" - ")
        start = parts[0].strip()
        end = parts[1].strip()
        streamData.append({"start": start, "end": end, "presentation_id": id})
    return streamData


def format_speaker(v):
    list_keys = ["sessions"]
    list_fields = {}
    for key in list_keys:
        list_fields[key] = extract_list_field(v, key)

    return v.copy() | {
        "sessions": list_fields["sessions"],
        "calendar": site_data["calendar_" + v["UID"]],
    }


# ITEM PAGES


@app.route("/poster_<poster>.html")
def poster(poster):
    uid = poster
    v = by_uid["papers"][uid]
    data = _data()
    data["paper"] = format_paper(v)
    data["calendar"] = [x | {"info_link": None} for x in site_data["calendar_" + uid]]
    return render_template("poster.html", **data)


@app.route("/prerecorded_<uid>.html")
def prerecorded(uid):
    v = by_uid["prerecorded"][uid]
    data = _data()
    data["talk"] = v
    if v["track"] in by_uid["workshops"]:
        data["track"] = by_uid["workshops"][v["track"]]["title"]
    return render_template("prerecorded.html", **data)


@app.route("/sponsor_<sponsor>.html")
def sponsor(sponsor):
    uid = sponsor
    v = by_uid["sponsors"][uid]
    data = _data()
    data["sponsor"] = v | site_data.get("sponsor_" + uid, site_data["sponsor_default"])
    data["calendar"] = site_data["calendar_" + uid]
    return render_template("sponsor.html", **data)


@app.route("/x_sponsor_<sponsor>.html")
def x_sponsor(sponsor):
    uid = sponsor
    v = by_uid["sponsors"][uid]
    data = _data()
    data["config"] = data["config"] | {"use_auth0": False}
    data["sponsor"] = v | site_data.get("sponsor_" + uid, site_data["sponsor_default"])
    data["calendar"] = site_data["calendar_" + uid]
    return render_template("x_sponsor.html", **data)


@app.route("/track_pldi-<track>.html")
def pldi_track(track):
    uid = "pldi-" + track
    v = by_uid["tracks"][uid]
    data = _data()
    data["track"] = v
    data["streams"] = format_track_streams(v)
    data["calendar"] = site_data["calendar_" + uid] + site_data["calendar_all_papers"]
    return render_template("pldi_track.html", **data)


@app.route("/track_<track>.html")
def track(track):
    uid = track
    v = by_uid["workshops"][uid]
    trackInfo = by_uid["tracks"][uid]
    data = _data()
    data["track"] = v
    data["abbrev"] = trackInfo["conf_abbrev"]

    cal_uid = uid
    if uid == "imop":
        cal_uid = "imop_special"
    data["calendar"] = [
        x | {"track": None, "target": "_blank"}
        for x in site_data["calendar_" + cal_uid]
        if x["category"] != "colocated-session"
    ] + [
        x | {"track": None, "info_link": None}
        for x in site_data["calendar_" + cal_uid]
        if x["category"] == "colocated-session"
    ]

    data["sponsors"] = site_data.get("sponsors_" + uid, list())

    talks = [
        x for x in site_data["prerecorded"] if x["track"] == track
    ]  # and x.get("presentation_id", "") != ""]
    talks = sorted(talks, key=lambda x: x["title"].upper())

    # Uncomment to add talks
    data["prerecorded"] = talks

    presentationIds = extract_list_field(trackInfo, "presentation_ids")

    data["zoom"] = zoomLink(zoomIDForTrack(uid))

    # if track == "contracts":
    #     return render_template("track_contracts.html", **data)
    if len(presentationIds) == 1:
        data["presentation_id"] = presentationIds[0]
        return render_template("track.html", **data)
    else:
        data["streams"] = format_track_streams(trackInfo)
        return render_template("track_multistream.html", **data)


@app.route("/chat.html")
def chat():
    data = _data()
    return render_template("chat.html", **data)


# FRONT END SERVING


@app.route("/papers.json")
def paper_json():
    json = []
    for v in site_data["papers"]:
        json.append(format_paper(v))
    return jsonify(json)


@app.route("/static/<path:path>")
def send_static(path):
    return send_from_directory("static", path)


@app.route("/serve_<path>.json")
def serve(path):
    return jsonify(site_data[path])


# --------------- DRIVER CODE -------------------------->
# Code to turn it all static


@freezer.register_generator
def generator():
    for paper in site_data["papers"]:
        yield "poster", {"poster": str(paper["UID"])}
    # speakers are in plenary
    # for speaker in site_data["speakers"]:
    #     yield "speaker", {"speaker": str(speaker["UID"])}
    # workshops are now tracks.
    # for workshop in site_data["workshops"]:
    #     yield "workshop", {"workshop": str(workshop["UID"])}
    for sponsor in site_data["sponsors"]:
        yield "sponsor", {"sponsor": str(sponsor["UID"])}
    for sponsor in site_data["sponsors"]:
        yield "x_sponsor", {"sponsor": str(sponsor["UID"])}
    for track in site_data["tracks"]:
        yield "track", {"track": str(track["UID"])}
    for track in ["A", "B"]:
        yield "pldi_track", {"track": track}

    # filter out pldi talks, and also blank lines
    for prerecorded in [
        x
        for x in site_data["prerecorded"]
        if x.get("track", "") in by_uid["tracks"]
        or x.get("track", "") in ["amas", "pldi-bus"]
    ]:
        yield "prerecorded", {"uid": prerecorded["UID"]}

    for key in site_data:
        yield "serve", {"path": key}


def parse_arguments():
    parser = argparse.ArgumentParser(description="MiniConf Portal Command Line")

    parser.add_argument(
        "--build",
        action="store_true",
        default=False,
        help="Convert the site to static assets",
    )

    parser.add_argument(
        "-b",
        action="store_true",
        default=False,
        dest="build",
        help="Convert the site to static assets",
    )

    parser.add_argument("path", help="Pass the JSON data path and run the server")

    args = parser.parse_args()
    return args


if __name__ == "__main__":
    args = parse_arguments()

    site_data_path = args.path
    extra_files = main(site_data_path)

    if args.build:
        freezer.freeze()
    else:
        debug_val = False
        if os.getenv("FLASK_DEBUG") == "True":
            debug_val = True

        app.run(host="0.0.0.0", port=5000, debug=debug_val, extra_files=extra_files)
